# refactoring

## 0 Markdown ##

Markdown은 텍스트 기반의 마크업 언어로 HTML로 변환이 가능하다.
특수기호와 문자를 이용한 매우 간단한 구조의 문법을 사용하여 웹에서도 보다 빠르게 컨텐츠를 작성하고 보다 직관적으로 인식할 수 있다.

### 1 장점 ###
```
1. 간결하다.
2. 별도의 도구 없이 작성가능하다.
3. 다양한 형태로 변환이 가능하다.
4. 텍스트로 저장되기 때문에 용량이 적어 보관이 용이하다.
5. 텍스트 파일이기 때문에 버전관리시스템을 이용하여 변경이력을 관리할 수 있다.
6. 지원하는 프로그램과 플랫폼이 다양하다.
```

### 2 단점 ###

>    1. 표준이 없다.
>    2. 표준이 없기 때문에 도구에 따라서 변환방식이나 생성물이 다르다.
>    3. 모든 HTML마크업을 대신하지 못한다.

---------------------------------------------------------

## 01 리팩터링 첫 번째 예시 ##
----------------------------------------
프로그램이 잘 작동하는 상황에서 그저 코드가 '지저분하다'는 이유로 불평하는 것은 프로그램의 구조를 너무 미적인 기준으로만 판단하는 건 아닐까? 컴파일러는 코드가 깔끔하든 지저분하든 개의치 않으니 말이다. 하지만 그 코드를 수정하려면 사람이 개입되고, 사람은 코드의 미적 상태에 민감하다.

**설계가 나쁜 시스템은 수정하기 어렵다.**

원하는 동작을 수행하도록 하기위해 수정해야 할 부분을 찾고, 기존 코드와 잘 맞물려 작동하게 할 방법을 강구하기가 어렵기 때문이다. 무엇을 수정할지 찾기 어렵다면 실수를 저질러서 버그가 생길 가능성도 높아진다.
*코드를 수정할 때면 먼저 프로그램의 작동 방식을 더 쉽게 파악할 수 있도록 코드를 여러 함수와 프로그램 요소로 재구성한다.* 프로그램의 구조가 빈약하다면 대체로 구조부터 바로잡은 뒤에 기능을 수정하는 편이 작업하기가 훨씬 수월하다.

> **프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다.**

이 코드에서 사용자의 입맛에 맞게 수정할 부분을 몇 개 발견했다. 가장 먼저 청구내역을 HTML로 출력하는 기능이 필요하다. 
이 변경이 어느 부분에 영향을 줄지 생각해보자. 우선 (HTML태그를 삽입해야 하니) 청구 결과에 문자열을 추가하는 문장 각각을 조건문으로 감싸야한다. 그러면 statement()함수의 복잡도가 크게 증가한다. 이런 상황이라면 대부분 *이 함수의 복사본을 만들고 복사본에서 HTML을 출력하는 식으로 처리할 것이다.*
이때 복사하는 일 자체는 그리 부담되지 않지만, 나중에 수많은 문제를 일으킬 여지가 있다. 청구서 작성 *로직을 변경할 때마다 기존 함수와 HTML버전 함수 모두를 수정하고, 항시 일관되게 수정했는지도 확인해야 한다.* 로직을 변경할 일이 절대 없다면 이렇게 복사해서 붙이는 방식도 상관없지만, 오래 사용할 프로그램이라면 중복 코드는 골칫거리가 된다.


이는 두 번째 변경 사항과도 관련이 있다. 
배우들은 사극, 전원극, 전원 희극, 역사 전원극, 역사 비극, 희비 역사 전원극, 장면 변화가 없는 고전극, 길이와 시간과 장소에 제약없는 자유극 등 더 많은 장르를 연기하고 싶어 한다. 언제 어떤 연극을 할지는 아직 결정하지 못했지만, 이 변경은 공연료와 적립 포인트 계산법에 영향을 줄 것이다. *어떤 방식으로 정하든 반드시 6개월 안에 다시 변경하게 될 것이다.* 새로운 요구사항은 수색 대원처럼 한두명씩이 아니라, 한 부대씩 몰려오기 마련이다.


 이처럼 연극 장르와 공연료 정책이 달라질 때마다 statement()함수를 수정해야 한다. 만약 statement()를 복사해서 별도의 htmlStatement()를 만든다면 모든 수정이 두 함수에 일관되게 반영되도록 보장해야 한다. 게다가 정책이 복잡해질수록 수정할 부분을 찾기 어려워지고 수정 과정에서 실수할 가능성도 커진다.

 **이것이 리팩터링이 필요한 이유이다.**

잘 작동하고 나중에 변경할 일이 절대 없다면 코드를 현재 상태로 놔둬도 아무런 문제가 없다. 하지만 다른 사람이 읽고 이해해야 할 일이 생겼는데 로직을 파악하기 어렵다면 뭔가 대책을 마련해야 한다.

----------------------

### 리팩터링의 첫 단계 ###
리팩터링의 첫 단계는 항상 똑같다.
*리팩터링할 코드 영역을 꼼꼼하게 검사해줄 테스트 코드들부터 마련해야 한다.* 리팩터링에서 테스트의 역할은 굉장히 중요하다. 리팩터링 기법들이 버그 발생 여지를 최소화하도록 구성됐다고는 하나 실제 작업은 사람이 수행하기 때문에 언제든 실수할 수 있다. 프로그램이 클수록 수정 과정에서 예상치 못한 문제가 발생할 가능성이 크다. 

statement()함수의 테스트는 어떻게 구성하면 될까? 이 함수가 문자열을 반환하므로, 다양한 장르의 공연들로 구성된 공연료 청구서 몇 개를 미리 작성하여 문자열 형태로 준비해둔다. 그런 다음 statement()가 반환한 문자열과 준비해둔 정답 문자열을 비교한다. 그리고 테스트 프레임워크를 이용하여 모든 테스트를 단축키 하나로 실행할 수 있도록 설정해둔다. 이 테스트는 몇 초면 끝날 것이며, 나중에 보겠지만 테스트를 수시로 한다. 

> **리팩터링하기 전에 제대로 된 테스트부터 마련한다. 테스트는 반드시 자가진단하도록 만든다.**

내가 저지른 실수로부터 보호해주는 버그 검출기 역할을 해주기 때문에 테스트에 상당히 의지해야 한다. 원하는 내용을 소스 코드와 테스트 코드 양쪽에 적어두면, 두 번 다 똑같이 실수하지 않는 한 버그 검출기에 반드시 걸린다. 이와 같은 중복 검사로 실수 가능성을 크게 줄일 수 있다. 테스트를 작성하는데 시간이 좀 걸리지만, 신경 써서 만들어두면 디버깅 시간이 줄어서 전체 작업 시간은 오히려 단축된다.

### statement() 함수 쪼개기 ###

statement()처럼 긴 함수를 리팩터링할 때는 먼저 전체 동작을 각각의 부분으로 나눌 수 있는 지점을 찾는다. 그러면 중간 즈음의 switch문이 가장 먼저 눈에 띌 것이다.   

이 switch 문을 살펴보면 한 번에 공연에 대한 요금을 계산하고 있다. 이러한 사실은 코드를 분석해서 얻은 정보다.   

이런 식으로 파악한 정보는 휘발성이 높기로 악명 높은 저장 장치인 내 머릿속에 기록되므로, 잊지 않으려면 빨리 코드에 반영해야 한다. 그러면 다음번에 코드를 볼 때, 다시 분석하지 않아도 코드 스스로가 자신이 하는 일이 무엇인지 이야기해줄 것이다.   

여기서는 코드 조각을 별도 함수로 추출하는 방식으로 앞서 파악한 정보를 코드에 반영할 것이다. 추출한 함수에는 그 코드가 하는 일을 설명하는 이름을 지어준다. amountFor(aPerformance)정도면 적당해 보인다. 이렇게 코드 조각을 함수로 추출할 때 실수를 최소화해주는 절차를 마련해뒀다. 이 절차를 따로 기록해두고, 나중에 참조하기 쉽도록 '함수 추출하기'란 이름으로 정리  

먼저 별도 함수로 빼냈을 때 유효범위를 벗어나는 변수, 즉 새 함수에서는 곧바로 사용할 수 없는 변수가 있는지 확인한다. 